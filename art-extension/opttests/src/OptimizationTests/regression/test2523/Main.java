/*
 * Copyright (C) 2015 Intel Corporation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Generated by Android Runtime Fuzzer tool (3.5.002). Fri Aug 21 15:22:56 2015
// srand = 28111801636640576202551473772488774539

package OptimizationTests.regression.test2523;

import OptimizationTests.regression.shared.*;

public class Main extends FuzzerUtils {

    public static final int N = 100;

    public static int iFld=-1, iFld1=4;
    public static byte byFld=-10;
    public static boolean bFld=false;
    public static short sFld=30703;

    public static long iMeth_check_sum = 0;
    public static long fMeth_check_sum = 0;

public static int iMeth() {

    int i3=11784, iArr1[]=new int[N];
    long l2=7695594881939844968L, lArr[][]=new long[N][N];
    float f1=-104.129F, fArr[]=new float[N];
    short s1=32494;
    boolean b=true, b1=false;
    double d=-1.109960;

    init(iArr1, -11);
    init(lArr, 2343643176813534692L);
    init(fArr, 19.146F);

    if (bFld && ((!(b = b1)) || ((l2 != byFld) != (l2 > iFld1)))) {
        for (i3 = 5; i3 < 93; i3++) {
            iArr1[i3 + 1] -= (byFld |= (byte)(iFld1++));
            iFld1 += iFld1;
            if ((++iFld1) >= (-((iFld + i3) >> iFld1))) {
                iFld1 -= (int)l2;
            } else {
                f1 = (iFld1 - (--iFld1));
                if (bFld = (bFld == ((-(--lArr[i3][i3 - 1])) >= iArr1[i3 + 1]))) {
                    iFld1 -= iFld1;
                } else if (fArr[i3 + 1] <= iArr1[i3]) {
                    iFld1 = (int)(((iFld1 + s1) * 24) % ((lArr[i3][i3 + 1] = (l2 * byFld)) | 1));
                    iFld1 = iFld;
                    iArr1[i3] = iArr1[i3 - 1];
                    return (int)(i3 + l2 + Float.floatToIntBits(f1) + s1 + (b ? 1 : 0) + (b1 ? 1 : 0) +
                        Double.doubleToLongBits(d) + checkSum(iArr1) + checkSum(lArr) +
                        Double.doubleToLongBits(checkSum(fArr)));
                }
            }
        }
    } else if (false) {
        fArr[(iFld1 >>> 1) % N] = (float)((-iFld1) - ((-17155 + (l2 - 2.27143)) * -81));
    } else {
        iArr1[(iFld1 >>> 1) % N] -= (int)(((--iFld1) - (-111 * Math.abs(138))) - ((iFld + d) - i3));
    }
    long meth_res = i3 + l2 + Float.floatToIntBits(f1) + s1 + (b ? 1 : 0) + (b1 ? 1 : 0) + Double.doubleToLongBits(d) +
        checkSum(iArr1) + checkSum(lArr) + Double.doubleToLongBits(checkSum(fArr));
    iMeth_check_sum += meth_res;
    return (int)meth_res;
}

public static float fMeth(long l3, int i6, int i7) {

    int i8=-47386, i9=49976, i10=172, iArr2[]=new int[N];
    double d2=-2.13217, dArr[]=new double[N];
    float f2=-2.771F;
    byte byArr[]=new byte[N];
    short sArr1[]=new short[N];

    init(iArr2, 22016);
    init(dArr, 1.25175);
    init(byArr, (byte)-116);
    init(sArr1, (short)-29726);

    for (i8 = 3; i8 < 83; ++i8) {
        i7 += (sFld - (iFld1 - (-33 - (iArr2[i8]++))));
    }
    switch (((((int)(iFld - 7643251439938321629L)) >>> 1) % 4) + 54) {
    case 54:
        for (i9 = 2; i9 < 82; i9++) {
            d2 %= (Math.max(iFld1, iArr2[i9 + 1]) | 1);
            for (f2 = i9; f2 < 77; ++f2) {
                iArr2[(int)(f2)] = (int)(--d2);
                bFld = (bFld || ((i6--) == iArr2[(int)(f2 - 1)]));
                i6 -= (int)f2;
            }
            iArr2[i9 + 1] += (int)(f2 - i8);
            i7 = (++i10);
            i7 -= (int)(dArr[i9 + 1]--);
        }
    case 55:
        byArr[(i6 >>> 1) % N] >>= (byte)(((sFld - i7) * (i6++)) - ((iArr2[(i10 >>> 1) % N]++) * (i7 - -153)));
        break;
    case 56:
        sArr1[(i8 >>> 1) % N] = (short)(--l3);
        break;
    case 57:
        i7 = (int)(((-57803 - (i7 = i8)) + (l3 << -39031)) * (--iFld1));
        break;
    }
    long meth_res = l3 + i6 + i7 + i8 + i9 + Double.doubleToLongBits(d2) + Float.floatToIntBits(f2) + i10 +
        checkSum(iArr2) + Double.doubleToLongBits(checkSum(dArr)) + checkSum(byArr) + checkSum(sArr1);
    fMeth_check_sum += meth_res;
    return (float)meth_res;
}

public static void main(String[] strArr) {

    long l=-155L, l1=-7199461766003221791L, lArr1[]=new long[N];
    int i=185, i1=-7, i2=246, i4=-155, i5=207, i11=-150, i12=-135, i13=8, iArr[]=new int[N];
    byte by=-107;
    short s=-26209, sArr[]=new short[N];
    float f=-89.993F, fArr1[]=new float[N], fArr2[]=new float[N];
    double d1=-2.100059;

    init(iArr, 33);
    init(sArr, (short)-3845);
    init(lArr1, -50169L);
    init(fArr1, 2.549F);
    init(fArr2, -109.172F);

    for (iFld = 2; iFld < 83; iFld++) {
        iArr[iFld - 1] = (int)(iFld + l);
    }
    for (i = 5; i < 96; i++) {
        iArr[i - 1] *= (iArr[i - 1]++);
        iFld1 >>= (int)((i1 -= (i1 + i)) - (l * 86));
        iArr[i - 1] >>>= by;
        iArr[i + 1] <<= (int)(((-14362 - (12 - (--iFld1))) - (--l)) << (iFld1 % ((s / (i1 | 1)) | 1)));
        i1 = (int)((++l) + ((s - iFld1) + iFld));
        iArr[i + 1] *= (int)(((--i1) + (iFld + 56472)) * (l1 * f));
        i1 = (int)((Math.min(i, i2) - (194 - (l1 - iFld1))) % (((by - -3783) * iMeth()) | 1));
        d1 *= (d1 = (Math.min(iFld, -244) * (-9 * (i1 - 460L))));
    }
    i4 = 1;
    do {
        i5 = 1;
        while (++i5 < 6) {
            iFld1 += (i5 * i5);
        }
        iFld1 += (-(--sArr[i4]));
        lArr1[i4 - 1] ^= (long)(i1 *= (int)f);
        if ((((i1--) % ((i4 + i5) | 1)) - ((fArr2[i4 + 1]--) * fMeth(36482L, i1, i))) < ((iFld1 * (i4 + i5)) + (d1 -
            (i2 + i1)))) {
            i2 = (((++iFld1) + (iFld1 + i4)) + (++i1));
            i1 = (int)fArr1[i4 + 1];
        }
    } while (++i4 < 93);
    i11 = 1;
    while (++i11 < 85) {
        for (i12 = i11; i12 < 73; ++i12) {
            for (i13 = 3; i13 < 59; i13++) {
                iArr[i11] = (int)((l1 + (l1 * 28236)) + (--i2));
                iFld1 += (int)(((i1 - 0.16764) - (i1 * i13)) * lArr1[i13 + 1]);
            }
            l1 *= i13;
        }
    }

    System.out.println("l i i1 = " + l + "," + i + "," + i1);
    System.out.println("by s l1 = " + by + "," + s + "," + l1);
    System.out.println("f i2 d1 = " + Float.floatToIntBits(f) + "," + i2 + "," + Double.doubleToLongBits(d1));
    System.out.println("i4 i5 i11 = " + i4 + "," + i5 + "," + i11);
    System.out.println("i12 i13 iArr = " + i12 + "," + i13 + "," + checkSum(iArr));
    System.out.println("sArr lArr1 fArr1 = " + checkSum(sArr) + "," + checkSum(lArr1) + "," +
        Double.doubleToLongBits(checkSum(fArr1)));
    System.out.println("fArr2 = " + Double.doubleToLongBits(checkSum(fArr2)));

    System.out.println("iFld iFld1 byFld = " + iFld + "," + iFld1 + "," + byFld);
    System.out.println("bFld sFld = " + (bFld ? 1 : 0) + "," + sFld);

    System.out.println("iMeth_check_sum: " + iMeth_check_sum);
    System.out.println("fMeth_check_sum: " + fMeth_check_sum);
}
}
