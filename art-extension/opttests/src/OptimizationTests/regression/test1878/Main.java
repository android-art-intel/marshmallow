/*
 * Copyright (C) 2015 Intel Corporation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Generated by Dalvik Fuzzer tool (3.5.001). Fri Apr  3 11:02:44 2015
package OptimizationTests.regression.test1878;

import OptimizationTests.regression.shared.*;

class UserDefinedException extends RuntimeException {
    public int field;
}

public class Main extends FuzzerUtils {

    public static final int N = 100;

    public static short sFld=-19076;

    public static long byMeth_check_sum = 0;
    public static long iMeth_check_sum = 0;

public static byte byMeth(int i4, int i5, int i6) {

    double d=-1.2795;
    byte by=65, byArr[]=new byte[N];
    float f1=-2.297F, fArr[]=new float[N];
    long l1=2L, lArr1[]=new long[N];
    int i7=13, iArr1[]=new int[N];

    init(iArr1, -187);
    init(fArr, -1.146F);
    init(lArr1, -1427870528L);
    init(byArr, (byte)110);

    i7 = 1;
    while (++i7 < 98) {
        i6 *= (int)d;
    }
    for (int i8 : iArr1) {
        i4 = i7;
        fArr[(i5 >>> 1) % N] *= (iArr1[(i4 >>> 1) % N] - ((i4 * i4) * (i5 - l1)));
        sFld += (short)(lArr1[(i6 >>> 1) % N] *= iArr1[(i7 >>> 1) % N]);
        f1 += (lArr1[(i8 >>> 1) % N] -= ((i6 + by) - (i7 * i7)));
        lArr1[(i5 >>> 1) % N] -= l1;
        byArr[(i8 >>> 1) % N] >>>= (byte)i7;
        l1 = (--l1);
        l1 = (i6 = (int)((l1 + by) + (l1 = i8)));
        lArr1[(i5 >>> 1) % N] = (++l1);
    }
    long meth_res = i4 + i5 + i6 + i7 + Double.doubleToLongBits(d) + l1 + Float.floatToIntBits(f1) + by +
        checkSum(iArr1) + Double.doubleToLongBits(checkSum(fArr)) + checkSum(lArr1) + checkSum(byArr);
    byMeth_check_sum += meth_res;
    return (byte)meth_res;
}

public static int iMeth(long l2, float f3, int i9) {

    double d1=-1.94244;
    long lArr2[]=new long[N];
    byte by1=-37;
    boolean b=false;
    int i11=-59854, i12=-6806, i13=-2, iArr2[]=new int[N];

    init(iArr2, -59665);
    init(lArr2, -1728624770258479784L);

    for (int i10 : iArr2) {
        for (i11 = 1; i11 < 98; i11++) {
            l2 = i9;
            i10 &= (int)(3 % ((long)((-(i9 + i12)) - (i12 - d1)) | 1));
            i10 = i10;
            f3 += (float)((--i12) * (-(d1 + i11)));
            for (i13 = 1; i13 < 8; ++i13) {
                f3 += (--lArr2[i11]);
                if (b || (!((--iArr2[i11]) == (i9 + i10)))) break;
                l2 += (i13 * f3);
                d1 *= (++by1);
                i9 >>= ((--iArr2[i11 - 1]) + (i12++));
            }
        }
    }
    long meth_res = l2 + Float.floatToIntBits(f3) + i9 + i11 + i12 + Double.doubleToLongBits(d1) + i13 + (b ? 1 : 0) +
        by1 + checkSum(iArr2) + checkSum(lArr2);
    iMeth_check_sum += meth_res;
    return (int)meth_res;
}

public static void main(String[] strArr) {

    short s=25500;
    double d2=2.23826, dArr[]=new double[N];
    byte by2=-67;
    float f=-1.315F, f2=0.756F, fArr1[]=new float[N];
    long l=-54518L, lArr[]=new long[N];
    int i=17892, i1=-178, i2=-9, i3=-181, i14=51347, i15=14970, i16=-143, iArr[]=new int[N];

    init(lArr, 2323223072L);
    init(dArr, -1.36241);
    init(iArr, 41891);
    init(fArr1, -2.532F);

    for (i = 1; i < 93; i++) {
        for (i1 = 3; i1 < 66; ++i1) {
            lArr[i] = ((l * l) + s);
            i2 -= (i2 &= i2);
            i2 = -27232;
            i2 = i2;
            l -= i3;
            l -= (s + l);
        }
        i2 /= (int)((long)(((l++) - (--dArr[i - 1])) + f) | 1);
        i3 += i;
        i3 *= (iArr[i - 1]--);
        i3 = byMeth((int)(-(-21691 - f2)), (int)((42 + (l * l)) + iArr[i - 1]), (int)((i - f2) * (--i3)));
        i2 += (52658 + (i * i));
        f2 -= (((iArr[i] = i1) * (l++)) - (lArr[i + 1]++));
        i2 = (i3 += iArr[i - 1]);
        iArr[i] >>= iMeth(++lArr[i - 1], (f2 - l) * l, Math.min(i2, (int)(d2 + i14)));
    }
    i15 = 1;
    do {
        l = (lArr[i15 - 1]--);
        try {
            for (i16 = 1; i16 < i15; ++i16) {
                by2 <<= (byte)((i14 - (sFld + i16)) * l);
                i2 ^= (int)(i3 - (++f2));
            }
            dArr[i15 - 1] = (--i2);
            iArr[i15 + 1] -= (i2--);
            sFld = (short)(++fArr1[i15 - 1]);
        }
        catch (UserDefinedException exc) {
            i3 -= (iArr[i15 - 1]++);
        }
    } while (++i15 < 90);

    System.out.println("i i1 l = " + i + "," + i1 + "," + l);
    System.out.println("s i2 i3 = " + s + "," + i2 + "," + i3);
    System.out.println("f f2 d2 = " + Float.floatToIntBits(f) + "," + Float.floatToIntBits(f2) + "," +
        Double.doubleToLongBits(d2));
    System.out.println("i14 i15 i16 = " + i14 + "," + i15 + "," + i16);
    System.out.println("by2 lArr dArr = " + by2 + "," + checkSum(lArr) + "," + Double.doubleToLongBits(checkSum(dArr)));
    System.out.println("iArr fArr1 = " + checkSum(iArr) + "," + Double.doubleToLongBits(checkSum(fArr1)));

    System.out.println("sFld = " + sFld);

    System.out.println("byMeth_check_sum: " + byMeth_check_sum);
    System.out.println("iMeth_check_sum: " + iMeth_check_sum);
}
}
