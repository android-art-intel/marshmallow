/*
 * Copyright (C) 2015 Intel Corporation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Generated by Dalvik Fuzzer tool (3.5.001). Sat Feb 21 17:05:08 2015
package OptimizationTests.regression.test1578_2;

import OptimizationTests.regression.shared.*;

public class Main extends FuzzerUtils {

    public static final int N = 100;

    public static short sFld=-10779;

public static void main(String[] strArr) {

    long l=-225L, l1=110156504L, lArr[][]=new long[N][N];
    byte by=-17, byArr[]=new byte[N];
    float f=-123.12F, fArr[]=new float[N];
    double d=0.75564;
    int i=36383, i1=-154, i2=10, i3=-34207, i4=36398, i5=12, iArr[]=new int[N], iArr1[]=new int[N], iArr2[]=null;

    init(iArr, 107);
    init(lArr, -13L);
    init(iArr1, -21237);
    init(byArr, (byte)-27);
    init(fArr, 71.39F);
    

    for (i = 4; i < 87; ++i) {
        iArr[i] <<= iArr[i - 1];
        for (i1 = 4; i1 < 69; ++i1) {
            i2 ^= (int)l;
            l1 *= ((i1 * (45 - i1)) / (((l + 89) & (i2 * -2968960481L)) | 1));
            lArr[i1 - 1][i] -= (l1--);
            l -= Float.floatToRawIntBits(f);
            i3 = 1;
            do {
                by += (byte)d;
            } while (++i3 < 81);
        }
        i4 = 1;
        do {
            i2 = (int)(39.622F - ((iArr1[i + 1]++) + (sFld * i1)));
            byArr[i4] = (byte)(++by);
            for (i5 = 5; i5 > 1; i5--) {
                l += (((i + i5) + Math.abs(i4)) - ((++l1) * (i2 = i1)));
                f = (float)(((i5 + i) + lArr[i4 + 1][i5 + 1]) - d);
                i2 *= (int)(((i2--) << (++by)) * l1);
                i2 = iArr[i + 1];
                i2 += (9 + (i5 * i5));
                d = (f - l1);
                try {
                    iArr1[i - 1] /= (int)((--lArr[i5 + 1][i5]) | 1);
                    i2 += i3;
                    d *= fArr[i5];
                    f += (i5 * i5);
                    iArr2[2] = 3;
                }
                catch (NullPointerException exc) {
                    i2 = (++i2);
                }
                finally {
                    if ((((l - i5) - i5) - (--l1)) >= (-((by + i) * (--f)))) break;
                }
            }
        } while (++i4 < 61);
    }

    System.out.println("i i1 i2 = " + i + "," + i1 + "," + i2);
    System.out.println("l l1 f = " + l + "," + l1 + "," + Float.floatToIntBits(f));
    System.out.println("i3 by d = " + i3 + "," + by + "," + Double.doubleToLongBits(d));
    System.out.println("i4 i5 iArr = " + i4 + "," + i5 + "," + checkSum(iArr));
    System.out.println("lArr iArr1 byArr = " + checkSum(lArr) + "," + checkSum(iArr1) + "," + checkSum(byArr));
    System.out.println("fArr iArr2 = " + Double.doubleToLongBits(checkSum(fArr)) + "," + 0);

    System.out.println("sFld = " + sFld);
}
}
