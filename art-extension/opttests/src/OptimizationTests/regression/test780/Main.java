/*
 * Copyright (C) 2015 Intel Corporation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Generated by Dalvik Fuzzer tool (3.4.001). Sat Oct 25 16:44:29 2014
package OptimizationTests.regression.test780;

import OptimizationTests.regression.shared.*;

public class Main extends FuzzerUtils {

    public static final int N = 100;

    public static double qqo[] = new double[N];
    public static int aru = -8782, dk[] = new int[N];
    public static float b = 0.495F;

    static {
        init(qqo, 10.393);
        init(dk, -59196);
    }

    public static long w_check_sum = 0;
    public static long t_check_sum = 0;

    public static void w(long hi, int df, byte nyr) {

        double st = -13.883;
        int i = 2086, wd = -63384, v5t = 43870, r1l[][] = new int[N][N];
        float gp = 111.175F;

        init(r1l, 1525);

        for (i = 3; i < 78; i++) {
            gp += (i * i);
        }
        for (wd = 5; wd < 82; wd++) {
            df = (int) ((st + (r1l[(i >>> 1) % N][wd] ^= (int) hi)) + hi);
            r1l[wd - 1][wd + 1] *= (int) gp;
            df >>= wd;
            df = (int) (hi = (--df));
            for (v5t = 22; v5t > 1; v5t--) {
                df -= v5t;
                hi += (r1l[wd - 1][v5t + 1]--);
                df = (int) st;
                df *= df;
            }
        }
        w_check_sum += hi + df + nyr + i + Float.floatToIntBits(gp) + wd
                + Double.doubleToLongBits(st) + v5t + checkSum(r1l);
    }

    public static int t(double vp) {

        byte eh = 70;
        int dl = -24504, x = -36366, k2r = 31306, fo = 25691, wc = -49303;
        long m = -3463289429610239288L, nz = -9194520284444455268L, vlz[] = new long[N];

        init(vlz, -7044419181258408731L);

        dl = 1;
        do {
            m = (long) ((dl + (-4779058388143780772L * (dl * b))) - (dl + (dl * 62016)));
            x %= (int) (nz | 1);
        } while (++dl < 88);
        dk[(x >>> 1) % N] += dl;
        k2r = 1;
        while (++k2r < 90) {
            x = (((--x) - (x + -51484)) - ((x <<= x) - x));
        }
        for (fo = 6; fo < 96; fo++) {
            x = (--x);
            vlz[fo] = (x - (-dk[fo]));
        }
        wc = 1;
        while (++wc < 83) {
            dk[wc + 1] = ((--x) & (--eh));
            dk[wc - 1] = (int) m;
        }
        long meth_res = Double.doubleToLongBits(vp) + dl + m + x + nz + k2r
                + fo + wc + eh + checkSum(vlz);
        t_check_sum += meth_res;
        return (int) meth_res;
    }

    public static void main(String[] e) {

        boolean uom = true, j3[] = new boolean[N];
        double ip = 63.764, q = 77.308;
        byte l6 = 14;
        int l = 47609, d = -30725, c = 59876, lr = -17773, n = 45505, b9m = -11453, j[] = new int[N];
        long g = 4621884370312124011L;

        init(j, -22252);
        init(j3, false);

        for (l = 6; l < 97; l += 2) {
            w(-j[l - 1], (int) (((++g) - qqo[l + 1]) + t(21272 - (l * l))), l6);
            d = dk[l + 1];
            g >>= (d++);
            for (c = 1; c < 78; c++) {
                g = (long) (ip - g);
                for (lr = l; lr < l; lr++) {
                    dk[l + 1] += (int) g;
                    d &= (d - (~c));
                    l6 = (byte) n;
                    ip /= (l | 1);
                    j[c - 1] -= (int) (((--d) + (-(-8391262997619673586L * (b / (d | 1))))) * (c - (lr * 4587833955605745124L)));
                    b9m -= l;
                    uom = j3[lr - 1];
                    g = (++b9m);
                    n = (int) g;
                }
                for (q = 2; q < 48; ++q) {
                    switch ((int) ((q % 4) + 105)) {
                    case 105:
                        b9m = (--b9m);
                        b -= ((j[l - 1]++) - n);
                        d = (int) ((ip--) + dk[c + 1]);
                        break;
                    case 106:
                        g = (n * ((g >> c) + (g * b9m)));
                        b9m = (j[(int) (q)] + b9m);
                        b9m -= dk[l + 1];
                        g *= (b9m + ((n - c) * (g--)));
                        break;
                    case 107:
                        try {
                            d = (c % -159);
                            aru = (113 / c);
                            aru = (n / -23);
                        } catch (ArithmeticException a_e) {
                        }
                        break;
                    case 108:
                        break;
                    default:
                        d = (-d);
                    }
                }
            }
        }

        System.out.println("l g l6 = " + l + "," + g + "," + l6);
        System.out.println("d c ip = " + d + "," + c + ","
                + Double.doubleToLongBits(ip));
        System.out.println("lr n b9m = " + lr + "," + n + "," + b9m);
        System.out.println("uom q j = " + (uom ? 1 : 0) + ","
                + Double.doubleToLongBits(q) + "," + checkSum(j));
        System.out.println("j3 = " + checkSum(j3));

        System.out.println("b aru qqo = " + Float.floatToIntBits(b) + "," + aru
                + "," + Double.doubleToLongBits(checkSum(qqo)));
        System.out.println("dk = " + checkSum(dk));

        System.out.println("w_check_sum: " + w_check_sum);
        System.out.println("t_check_sum: " + t_check_sum);
    }
}
