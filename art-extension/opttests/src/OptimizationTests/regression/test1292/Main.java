/*
 * Copyright (C) 2015 Intel Corporation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Generated by Dalvik Fuzzer tool (3.5.001). Wed Jan 28 10:38:34 2015
package OptimizationTests.regression.test1292;

import OptimizationTests.regression.shared.*;

public class Main extends FuzzerUtils {

    public static final int N = 100;

    public static long lFld=3265651770L;
    public static int iFld=-8, iArrFld[]=new int[N];
    public static short sArrFld[]=new short[N];
    public static double dFld=-2.5996;

    static {
        init(iArrFld, -5);
        init(sArrFld, (short)25935);
    }

    public static long iMeth_check_sum = 0;
    public static long lMeth_check_sum = 0;

public static int iMeth() {

    long l=-4044567094586681704L;
    byte by=90;
    int i1=-10, i2=-80, i3=56815, i4=-201, i5=63978, i6=-219, iArr1[]=new int[N];
    short s=26486;
    float f1=-121.5F;
    double d=-9.31952;

    init(iArr1, -8388);

    for (i1 = 95; i1 > 4; i1--) {
        i2 = (int)(((i2 - f1) * 43.105479) - iArr1[i1]);
        i3 = 1;
        do {
            for (i4 = 1; i4 < 29; i4++) {
                iArr1[i3 + 1] = ((i2 += (i3 + i4)) + -205);
                i2 /= (Integer.reverseBytes(i3) | 1);
                i2 = (int)(((by++) - (14 + (l + i1))) - ((--i2) % ((i1 + 104) | 1)));
            }
            i2 >>= (int)(f1 + (i4 - (d + i3)));
            i2 = (int)(Integer.reverseBytes(s << 10030) * l);
            i2 = (int)(i4 + (-(d - -1)));
            i5 = (int)(((i6 - i5) - (i2 - d)) * (++f1));
            l = i1;
        } while (++i3 < 21);
    }
    long meth_res = i1 + i2 + Float.floatToIntBits(f1) + i3 + i4 + by + l + Double.doubleToLongBits(d) + s + i5 + i6 +
        checkSum(iArr1);
    iMeth_check_sum += meth_res;
    return (int)meth_res;
}

public static long lMeth(long l1, int i8, double d1) {

    long lArr[]=new long[N];
    int i9=165, i10=-239;
    short s1=-21350;
    float f2=1.303F;

    init(lArr, 539543906129797702L);

    iFld = 1;
    while (++iFld < 96) {
        i9 = 1;
        while ((i9 += 2) < 90) {
            try {
                i8 = (i8 % iArrFld[iFld - 1]);
                iArrFld[i9 - 1] = (i8 / iFld);
                i8 = (-496012717 % iFld);
            } catch (ArithmeticException a_e) {}
            i10 = 1;
            do {
                i8 = (int)(i9 - lFld);
                f2 = i9;
                iArrFld[i9] /= (int)((long)(((-3 - f2) * l1) % (((i10 - -11) + (i10 + i10)) | 1)) | 1);
                i8 = (int)(-(lFld <<= i8));
            } while (++i10 < iFld);
            i8 += (int)(((iFld - iFld) + f2) + iArrFld[iFld - 1]);
            i8 *= (int)lArr[iFld + 1];
            i8 = (int)f2;
            s1 <<= (short)i10;
        }
    }
    long meth_res = l1 + i8 + Double.doubleToLongBits(d1) + i9 + i10 + Float.floatToIntBits(f2) + s1 + checkSum(lArr);
    lMeth_check_sum += meth_res;
    return (long)meth_res;
}

public static void main(String[] strArr) {

    long lArr1[]=new long[N];
    byte by1=11;
    int i=14719, i7=18670, i11=-23, i12=842, i13=-56176, iArr[]=new int[N];
    float f3=59.187F, fArr[]=new float[N];
    boolean b=false, bArr[]=new boolean[N];
    double d2=0.100954;

    init(fArr, -1.507F);
    init(iArr, 0);
    init(bArr, true);
    init(lArr1, -61102L);

    for (float f : fArr) {
        iArr[(i >>> 1) % N] += (++iArr[(i >>> 1) % N]);
        i = (iMeth() - (++i));
        lFld *= (long)(i7 = (int)(lMeth(lFld, iFld, dFld) - (--dFld)));
    }
    for (i11 = 2; i11 < 80; i11++) {
        if (iFld != by1) continue;
        dFld += (lMeth(lFld, iFld, dFld--) + ((lFld + i) + (i7 + i7)));
        sArrFld[i11] = (short)(i7--);
        if (bArr[i11]) break;
        i7 = i11;
        iArr[i11] = (int)(fArr[i11 + 1] + (iArr[i11 + 1] / ((i - by1) | 1)));
        dFld *= (i--);
        i7 += (-12897 + (i11 * i11));
    }
    i12 = 88;
    while (--i12 > 0) {
        dFld -= ((f3 * (i + 130)) - 49L);
        by1 += (byte)(dFld + ((lFld + i12) - (++by1)));
        i7 -= (i7 = (i12 - 61));
    }
    lMeth(--lArr1[(iFld >>> 1) % N], i11, ((iFld - lFld) - (lFld - 83)) * (-lFld));
    for (d2 = 2; d2 < 85; ++d2) {
        i7 += (-21 + (d2 * d2));
        dFld = ((--i) - (--f3));
    }
    for (i13 = 3; i13 < 93; ++i13) {
        i7 >>= (int)(((-4 - (i++)) + (f3 + -2.717F)) + Float.intBitsToFloat(~(iArr[i13 - 1] = i11)));
        b = (((lFld >>> 4553) - (i7++)) != -1L);
    }
    lMeth(lFld + (i7--), i, -iFld);

    System.out.println("i i7 i11 = " + i + "," + i7 + "," + i11);
    System.out.println("by1 i12 f3 = " + by1 + "," + i12 + "," + Float.floatToIntBits(f3));
    System.out.println("d2 i13 b = " + Double.doubleToLongBits(d2) + "," + i13 + "," + (b ? 1 : 0));
    System.out.println("fArr iArr bArr = " + Double.doubleToLongBits(checkSum(fArr)) + "," + checkSum(iArr) + "," +
        checkSum(bArr));
    System.out.println("lArr1 = " + checkSum(lArr1));

    System.out.println("lFld iFld dFld = " + lFld + "," + iFld + "," + Double.doubleToLongBits(dFld));
    System.out.println("iArrFld sArrFld = " + checkSum(iArrFld) + "," + checkSum(sArrFld));

    System.out.println("iMeth_check_sum: " + iMeth_check_sum);
    System.out.println("lMeth_check_sum: " + lMeth_check_sum);
}
}
