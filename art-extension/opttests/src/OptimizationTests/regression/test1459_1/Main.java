/*
 * Copyright (C) 2015 Intel Corporation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Generated by Dalvik Fuzzer tool (3.5.001). Fri Feb  6 22:34:45 2015
package OptimizationTests.regression.test1459_1;

import OptimizationTests.regression.shared.*;

public class Main extends FuzzerUtils {

    public static final int N = 100;

    public static int iFld=8, iArrFld[]=new int[N];
    public static byte byFld=-9;

    static {
        init(iArrFld, -39992);
    }

    public static long vMeth_check_sum = 0;
    public static long iMeth_check_sum = 0;

public static void vMeth(int i3, int i4) {

    int i5=-42137, i6=15343, i7=41799, i8=-30234;
    long l1=-26L, lArr1[][]=new long[N][N];
    float f2=0.714F;
    double d1=-125.7655, d2=-98.39046;

    init(lArr1, -1910528619L);

    i5 = 1;
    do {
        byFld -= (byte)(((f2 = i5) + d1) + (-58773 * iArrFld[i5]));
        i4 ^= ((++i3) * 10);
        i3 = (int)(l1 + ((l1 - -106.849F) + (i4++)));
        i6 = 1;
        do {
            i7 += (-26435 + (i6 * i6));
            for (i8 = 1; i8 < 21; i8 += 2) {
                if (((l1++) + lArr1[i5 - 1][i8]) == (-((2848259420L * (--i7)) * (f2 * i6)))) continue;
                l1 += (long)(d2--);
                i3 += (i8 + i7);
                i4 = i4;
                iArrFld[i5] *= ((++i3) ^ i5);
            }
        } while (++i6 < 63);
    } while (++i5 < 84);
    vMeth_check_sum += i3 + i4 + i5 + Float.floatToIntBits(f2) + Double.doubleToLongBits(d1) + l1 + i6 + i7 + i8 +
        Double.doubleToLongBits(d2) + checkSum(lArr1);
}

public static int iMeth(int i9, int i10) {

    int i11=201, i12=-125;
    long l2=-19893L;
    double d3=-2.46399;

    i11 = 1;
    while (++i11 < 89) {
        d3 = (iArrFld[i11]--);
        i10 = (int)l2;
        i9 += (int)(-83 + ((i10 - 70) - (i12 + 71.19236)));
        i12 = (int)((l2 = (i12 * 2)) - ((i9 - 0) + i10));
    }
    long meth_res = i9 + i10 + i11 + Double.doubleToLongBits(d3) + l2 + i12;
    iMeth_check_sum += meth_res;
    return (int)meth_res;
}

public static void main(String[] strArr) {

    int i=-185, i1=55, i2=-12;
    boolean b=true, bArr[]=new boolean[N];
    long lArr[]=new long[N];
    float f=-120.802F, f1=1.390F, fArr[]=new float[N];
    short s=-27435, sArr[]=new short[N];
    double d=1.119342, dArr[]=new double[N];

    init(lArr, -3295371271137177365L);
    init(bArr, true);
    init(dArr, 0.101583);
    init(sArr, (short)21658);
    init(fArr, -17.242F);

    if ((--i1) >= (d--)) {
        for (long l : lArr) {
            if (bArr[((-(i * i1)) >>> 1) % N]) {
                iArrFld[(i >>> 1) % N] = -20216;
                d -= 1;
                l = (i ^= (int)(-(i * l)));
                iArrFld[(i1 >>> 1) % N] = (int)l;
            } else {
                for (iFld = 3; iFld < 79; iFld++) {
                    i *= (int)lArr[iFld];
                    for (i2 = 6; i2 < 98; i2++) {
                        i1 += (49509 + (i2 * i2));
                        l >>= i;
                        i1 >>= (int)(((s + f) * (--dArr[(26 >>> 1) % N])) - ((-(s % (i | 1))) - (-1486 ^ iFld)));
                        l = ((long)((i1 ^= i2) / ((long)(d - i2) | 1)) | (l + (sArr[iFld + 1]--)));
                        l = Short.reverseBytes((short)(s--));
                        f -= (f + 8589);
                        l = (long)Float.intBitsToFloat((int)((33 + (d++)) + (++d)));
                        l = (long)(l / ((long)(l *= (long)(i1 * 0.726F)) | 1));
                        iArrFld[i2] ^= 2;
                    }
                    i = (++i1);
                    fArr[iFld - 1] = (-(i2 + i2));
                    byFld += (byte)((i++) - ((10 * (-3 * (i = iFld))) << -10));
                    f1 += (31555 + (iFld * iFld));
                    f1 = (lArr[iFld - 1]--);
                    l -= i2;
                }
            }
        }
    } else if (b) {
        vMeth(iMeth(iArrFld[(i1 >>> 1) % N], i2), --i);
    } else {
        i1 += (((-(i1 - i1)) + (-iMeth(i1, iFld))) - i);
    }

    System.out.println("i d i1 = " + i + "," + Double.doubleToLongBits(d) + "," + i1);
    System.out.println("i2 s f = " + i2 + "," + s + "," + Float.floatToIntBits(f));
    System.out.println("f1 b lArr = " + Float.floatToIntBits(f1) + "," + (b ? 1 : 0) + "," + checkSum(lArr));
    System.out.println("bArr dArr sArr = " + checkSum(bArr) + "," + Double.doubleToLongBits(checkSum(dArr)) + "," +
        checkSum(sArr));
    System.out.println("fArr = " + Double.doubleToLongBits(checkSum(fArr)));

    System.out.println("iFld byFld iArrFld = " + iFld + "," + byFld + "," + checkSum(iArrFld));

    System.out.println("vMeth_check_sum: " + vMeth_check_sum);
    System.out.println("iMeth_check_sum: " + iMeth_check_sum);
}
}
