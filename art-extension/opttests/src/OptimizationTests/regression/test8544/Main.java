/*
 * Copyright (C) 2015 Intel Corporation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Generated by Dalvik Fuzzer tool (3.5.001). Thu Apr 23 19:08:05 2015
package OptimizationTests.regression.test8544;

import OptimizationTests.regression.shared.*;

public class Main extends FuzzerUtils {

    public static final int N = 100;

    public static long lArrFld[]=new long[N];

    static {
        init(lArrFld, 3782969396L);
    }

    public static long iMeth_check_sum = 0;

public static int iMeth(long l2, double d1) {

    short s1=21894;
    boolean b1=false;
    float f1=0.2F;
    int i5=-3, i6=10, i7=-178, i8=19, i9=62608;

    i5 = 1;
    while (++i5 < 96) {
        i6 = i5;
        l2 *= (long)(0.944F * (--i6));
        for (i7 = 3; i7 < 97; i7++) {
            i6 >>= (int)l2;
            i6 += (int)(((l2 - f1) - (i5 % (l2 | 1))) * i5);
            i6 = (int)(((f1 - i5) * (i8 - i7)) * ((l2 + i8) + (i6 >>> i7)));
            s1 += (short)(i7 - f1);
            i9 += (-252 + (i7 * i7));
            b1 = b1;
            i6 += (int)-1.22830;
        }
        l2 <<= (long)(l2 * (d1 - i8));
    }
    long meth_res = l2 + Double.doubleToLongBits(d1) + i5 + i6 + i7 + Float.floatToIntBits(f1) + i8 + s1 + i9 + (b1 ? 1
        : 0);
    iMeth_check_sum += meth_res;
    return (int)meth_res;
}

public static void main(String[] strArr) {

    short s=-9038, sArr[]=new short[N];
    byte by=-118;
    long l=-4096833091L, l1=-5L;
    boolean b=false;
    float f=49.222F;
    int i=-6717, i1=-9, i2=-5452, i3=11, i4=11, i10=-5, iArr[]=new int[N];
    double d=-122.36497;

    init(sArr, (short)-25925);
    init(iArr, 36609);

    i = 1;
    while (++i < 91) {
        for (i1 = 5; i1 < 83; i1++) {
            i2 = ((i2--) + 11580);
            i2 -= (int)(((i1 + l) + (i2 + l1)) + (lArrFld[i + 1] - (i1 + f)));
            i2 |= 3114;
            i3 = (i + (by--));
        }
        if (b = b) {
            i3 += (++i3);
        } else {
            i3 <<= (-Math.max(-4 * i, (int)(i2 *= (int)l)));
            i4 = 1;
            while (++i4 < 4) {
                l1 = (long)(((i - l1) + Long.reverseBytes(l)) - (-236 - (i4 * d)));
                f -= -61804;
                if (((d + lArrFld[i4 + 1]) + (d *= (sArr[(i2 >>> 1) % N] = (short)d))) >= l1) continue;
                i2 += (int)(i1 + ((l1 + i) - (by * i1)));
                i2 = 69;
                iArr[i4 + 1] = (--s);
                i3 = (int)(-2465120138L * ((++i2) + (-92.442F - (i3 >> i4))));
                lArrFld[i] -= (l--);
                l += (i4 ^ i3);
            }
        }
        i2 = (int)((long)((f + 52.466F) + (-1825874661L * (l -= 14287))) ^ iArr[i - 1]);
        iArr[i + 1] = (int)((iMeth(19555L, d) - (i4 - 7816245505427723479L)) + (++i2));
        l1 += (i | i1);
    }
    i10 = 1;
    do {
        l1 = (i3 * (i3 - 7402770041515672163L));
        l1 -= i;
    } while (++i10 < 97);

    System.out.println("i i1 i2 = " + i + "," + i1 + "," + i2);
    System.out.println("l l1 f = " + l + "," + l1 + "," + Float.floatToIntBits(f));
    System.out.println("i3 by b = " + i3 + "," + by + "," + (b ? 1 : 0));
    System.out.println("i4 d s = " + i4 + "," + Double.doubleToLongBits(d) + "," + s);
    System.out.println("i10 sArr iArr = " + i10 + "," + checkSum(sArr) + "," + checkSum(iArr));

    System.out.println("lArrFld = " + checkSum(lArrFld));

    System.out.println("iMeth_check_sum: " + iMeth_check_sum);
}
}
