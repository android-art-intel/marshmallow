/*
 * Copyright (C) 2015 Intel Corporation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Generated by Android Runtime Fuzzer tool (3.5.002). Sat Sep  5 20:35:34 2015
// srand = 155997301490225266994831513144156112654

package OptimizationTests.regression.test2605;

import OptimizationTests.regression.shared.*;

public class Main extends FuzzerUtils {

    public static final int N = 100;


    public static long iMeth_check_sum = 0;

public static int iMeth(int i1) {

    int i2=56111, i3=-183, i4=12, iArr1[]=new int[N];
    long l2=-13L, l3=-108L;
    byte by1=-94;

    init(iArr1, 30681);

    i2 = 1;
    while (++i2 < 78) {
        i1 += i2;
    }
    for (i3 = 4; i3 < 94; i3++) {
        i1 *= (int)((--l2) - (l2++));
        i1 |= (int)(l2++);
        iArr1[i3 - 1] -= (-Math.abs((int)(l3 * i1)));
    }
    for (i4 = 92; i4 > 2; --i4) {
        i1 -= (i1 ^= 196);
        i1 += (int)(-73.476F + (i4 * i4));
        by1 += (byte)(i4 * i2);
        if (i3 != 0) {
            return (int)(i1 + i2 + i3 + l2 + l3 + i4 + by1 + checkSum(iArr1));
        }
        by1 = (byte)i1;
    }
    long meth_res = i1 + i2 + i3 + l2 + l3 + i4 + by1 + checkSum(iArr1);
    iMeth_check_sum += meth_res;
    return (int)meth_res;
}

public static void main(String[] strArr) {

    int i=186, i5=21316, i6=11, iArr[]=new int[N];
    byte by=-68;
    boolean b=true, bArr[]=new boolean[N];
    float f=2.804F;
    double d=-115.65605, d1=-68.38266;
    long l1=6L, l4=1923920715L, lArr[]=new long[N];
    short s=-4552, sArr[]=new short[N];

    init(lArr, -52746L);
    init(sArr, (short)-15253);
    init(iArr, -10);
    init(bArr, false);

    for (long l : lArr) {
        if (((i++) < l) & (b = (b != (l <= by)))) {
            sArr[(i >>> 1) % N] = (short)((-(192 - (l * i))) + i);
            by -= (byte)-21622;
        } else {
            i -= (int)(f = (i - (--i)));
            iArr[(i >>> 1) % N] |= (--i);
            iArr[(10 >>> 1) % N] *= (int)(((long)(128 + (-(f + l))) & (long)(i + f)) - by);
            i -= (++i);
        }
        f += i;
    }
    for (d = 1; d < 80; ++d) {
        l1 = (long)103.970F;
        i = (((i * i) * iMeth(i)) + ((i + i5) - (i5 + 14)));
        i5 >>= i;
        iArr[(int)(d - 1)] *= i;
        i5 <<= (int)(l1++);
        i = (int)((-82L * (i5 - -212)) * (i += (i5 + i5)));
        if (bArr[(int)(d + 1)] || (((-i6) <= (i * i5)) == false)) {
            i5 = (-((i - -16169) + (i5 *= i5)));
            for (i6 = 1; i6 < 98; i6++) {
                l1 -= ((-(i--)) + (i--));
                lArr[(int)(d)] += (((l4++) & (i++)) - (--l1));
                iArr[i6 + 1] += s;
                i += (int)l4;
                d1 *= -533894061034185641L;
                f = (by -= (byte)i6);
            }
        } else {
            i *= (int)(iArr[(int)(d + 1)] + d1);
        }
    }

    System.out.println("i by b = " + i + "," + by + "," + (b ? 1 : 0));
    System.out.println("f d l1 = " + Float.floatToIntBits(f) + "," + Double.doubleToLongBits(d) + "," + l1);
    System.out.println("i5 i6 l4 = " + i5 + "," + i6 + "," + l4);
    System.out.println("s d1 lArr = " + s + "," + Double.doubleToLongBits(d1) + "," + checkSum(lArr));
    System.out.println("sArr iArr bArr = " + checkSum(sArr) + "," + checkSum(iArr) + "," + checkSum(bArr));


    System.out.println("iMeth_check_sum: " + iMeth_check_sum);
}
}
