/*
 * Copyright (C) 2015 Intel Corporation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Generated by Dalvik Fuzzer tool (3.5.001). Fri Jan  9 22:46:01 2015
package OptimizationTests.regression.test1129;

import OptimizationTests.regression.shared.*;

public class Main extends FuzzerUtils {

    public static final int N = 100;


public static void main(String[] strArr) {

    boolean b=false, bArr[]=new boolean[N];
    float f=115.32F, f1=-1.488F, f2=-16.149F, fArr[]=new float[N];
    double d=119.49157;
    short s=19149, sArr[]=new short[N];
    byte by=-100;
    long l=-14L, l1=4550086329556923232L, l2=4738730905856953129L, lArr[]=new long[N];
    int i=-29243, i1=157, i2=3, i3=-9510, i4=0, i5=-13, iArr[][]=new int[N][N], iArr1[]=new int[N];

    init(iArr, -2);
    init(fArr, 2.499F);
    init(iArr1, -5);
    init(sArr, (short)-31044);
    init(lArr, 7039598076691545787L);
    init(bArr, false);

    i = 1;
    while (++i < 78) {
        i1 *= (int)((-(i1--)) * l);
        i1 += (i + i1);
        for (i2 = 1; i2 < i; i2++) {
            iArr[i + 1][i2] += i;
            l *= (long)(((d + l) * (f % (i1 | 1))) - (-(l1 + f)));
            i1 += (((i2 * l1) + i2) - i);
            l1 *= (((114 + (l1 + 22419)) * i) + i1);
            fArr[i] *= ((f++) + (i1++));
            for (i3 = i; i3 < i2; ++i3) {
                l1 = (long)(48793 * Double.longBitsToDouble(7706585727979469639L));
                l1 = (-(++i1));
            }
            iArr[i][i] >>= (int)(((l1 = l1) - (-(i3 - i))) - i);
            if (b = (b = ((i1 * l1) >= (by - i1)))) {
                iArr1[i] *= (int)(f -= (++by));
                i1 <<= (int)(-(-(l1 - i2)));
            } else {
                iArr1[i + 1] = (--i1);
                l = (long)((++sArr[i + 1]) - (f - (l2 - i2)));
            }
            i1 += (((i2 * f1) + i1) - f2);
        }
    }
    for (long l3 : lArr) {
        l2 = ((++i1) - i3);
        i4 = 96;
        do {
            i1 += ((long)i4 ^ (long)f);
            i1 -= (int)(((i & i3) * (i3 + f2)) - ((--s) % ((i5 + i2) | 1)));
            bArr[i4 - 1] = bArr[i4 + 1];
        } while (--i4 > 0);
    }

    System.out.println("i i1 l = " + i + "," + i1 + "," + l);
    System.out.println("i2 d f = " + i2 + "," + Double.doubleToLongBits(d) + "," + Float.floatToIntBits(f));
    System.out.println("l1 i3 by = " + l1 + "," + i3 + "," + by);
    System.out.println("b l2 f1 = " + (b ? 1 : 0) + "," + l2 + "," + Float.floatToIntBits(f1));
    System.out.println("f2 i4 s = " + Float.floatToIntBits(f2) + "," + i4 + "," + s);
    System.out.println("i5 iArr fArr = " + i5 + "," + checkSum(iArr) + "," + Double.doubleToLongBits(checkSum(fArr)));
    System.out.println("iArr1 sArr lArr = " + checkSum(iArr1) + "," + checkSum(sArr) + "," + checkSum(lArr));
    System.out.println("bArr = " + checkSum(bArr));

}
}
