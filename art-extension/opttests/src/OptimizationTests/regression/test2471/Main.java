/*
 * Copyright (C) 2015 Intel Corporation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Generated by Android Runtime Fuzzer tool (3.5.002). Sun Aug 16 01:59:42 2015
// srand = 49744095043083073897122760251922208345

package OptimizationTests.regression.test2471;

import OptimizationTests.regression.shared.*;

public class Main extends FuzzerUtils {

    public static final int N = 100;


public static void main(String[] strArr) {

    float f=-1.241F, f1=0.793F;
    int i=10, i1=-158, iArr[][]=new int[N][N];
    long l=1L, l1=-920976884L, l2=127L, lArr[]=new long[N];
    boolean b=false;
    double d=-86.115264;
    short s=4478;
    byte by=22, byArr[]=new byte[N];

    init(lArr, 1006954747L);
    init(byArr, (byte)20);
    init(iArr, -31026);

    f = 1;
    while (++f < 97) {
        i = 1;
        while (++i < 27) {
            lArr[i] = (~(i1--));
            if (true) {
                i1 = (i - i);
            } else if (((l1 + i) <= (i1--)) == (((i - i) + Math.abs(-4L)) >= (l1--))) {
                f1 *= i;
                l += i;
                l += i1;
            } else if (b = b) {
                lArr[i + 1] = (++l);
            }
            switch ((int)((f % 2) + 46)) {
            case 46:
                i1 -= byArr[i + 1];
                iArr[i + 1][i + 1] -= (((iArr[(int)(f + 1)][(int)(f + 1)]++) * 12) + i1);
                i1 = (int)(f1--);
                l1 -= ((-3547 + (-24747 + Integer.reverseBytes(i1))) * Math.abs((int)(i1 - -11357L)));
                break;
            case 47:
                i1 /= (int)(l | 1);
                d = iArr[(int)(f)][i];
                i1 = (++i1);
                i1 -= s;
            default:
                l1 += (long)(((l + i1) + f) - i);
                i1 >>>= -145;
                i1 *= (int)f1;
            }
            i1 ^= (i - -68);
            l += l2;
            i1 = (int)((-by) + (lArr[i]++));
            b = (((i1++) >= Integer.reverseBytes(i)) == (!(i1 <= i)));
        }
    }

    System.out.println("f i i1 = " + Float.floatToIntBits(f) + "," + i + "," + i1);
    System.out.println("f1 l l1 = " + Float.floatToIntBits(f1) + "," + l + "," + l1);
    System.out.println("b d s = " + (b ? 1 : 0) + "," + Double.doubleToLongBits(d) + "," + s);
    System.out.println("l2 by lArr = " + l2 + "," + by + "," + checkSum(lArr));
    System.out.println("byArr iArr = " + checkSum(byArr) + "," + checkSum(iArr));

}
}
