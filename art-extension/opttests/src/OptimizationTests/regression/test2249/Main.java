/*
 * Copyright (C) 2015 Intel Corporation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Generated by Android Runtime Fuzzer tool (3.5.002). Mon Jul 13 12:49:36 2015
// srand = 15238104916030760501860602478146838002005411463366387409232067721652

package OptimizationTests.regression.test2249;

import OptimizationTests.regression.shared.*;

public class Main extends FuzzerUtils {

    public static final int N = 100;

    public static int iFld=8855;
    public static float fFld=71.227F;

    public static long dMeth_check_sum = 0;

public static double dMeth(double d) {

    boolean b=false, bArr[]=new boolean[N];
    byte by=-113;
    int i=143, i1=-22634, i3=48, iArr[]=new int[N];
    short s=31550, sArr[]=new short[N];
    float f=2.35F;
    long l=-8131774303640846681L;

    init(iArr, 44);
    init(sArr, (short)-24829);
    init(bArr, true);

    if (bArr[(i >>> 1) % N]) {
        i = 1;
        while (++i < 90) {
            i1 += (58 + (i * i));
            iArr[i] = (-sArr[i - 1]);
        }
        for (int i2 : iArr) {
            i2 |= (int)(((-47673 + (l * l)) - f) - i);
            i2 = s;
            iArr[(i >>> 1) % N] = i2;
            f -= i2;
            for (i3 = 4; i3 < 82; ++i3) {
                i2 += (int)(((i2 -= i2) * i1) + ((l = -118) * f));
                if (b) continue;
            }
        }
    } else if (-203 != i) {
        d -= ((i + by) * (++iArr[(i3 >>> 1) % N]));
    } else if (b) {
        i1 %= (int)(((long)((f * (i1 ^= i1)) - (l++))) | 1);
    }
    long meth_res = Double.doubleToLongBits(d) + i + i1 + l + Float.floatToIntBits(f) + s + i3 + (b ? 1 : 0) + by +
        checkSum(iArr) + checkSum(sArr) + checkSum(bArr);
    dMeth_check_sum += meth_res;
    return (double)meth_res;
}

public static void main(String[] strArr) {

    boolean b1=false;
    double d1=0.106742, d2=0.79147;
    byte by1=48;
    int i4=-7, i5=13411, i6=141, i7=-12, i8=-1, iArr1[][]=new int[N][N], iArr2[]=new int[N];
    float fArr[]=new float[N];
    long l1=466L, lArr[]=new long[N];
    short s1=-8618;

    init(iArr1, 34486);
    init(lArr, -31124L);
    init(iArr2, 17187);
    init(fArr, -58.286F);

    switch (((((int)(64 * (-dMeth(d1)))) >>> 1) % 2) + 14) {
    case 14:
        i4 = 1;
        do {
            switch ((((((int)(i5 %= (int)190L)) >>> 1) % 1) * 5) + 2) {
            case 6:
                i5 *= iArr1[i4][i4];
                for (iFld = 48; iFld > 2; iFld--) {
                    by1 *= (byte)(lArr[iFld + 1]--);
                    i5 -= i4;
                    i6 = 1;
                    while (++i6 < 25) {
                        switch (((((i5--) >>> 1) % 4) * 5) + 109) {
                        case 128:
                            i5 >>= ((i7 = (s1 >> iFld)) - (Math.abs(i6) - i6));
                            i7 >>>= (int)(63559 * (0 + (67.518F - (-39840 - i7))));
                            iArr1[iFld][iFld] *= (iArr1[i4 - 1][i6 - 1]--);
                            break;
                        case 123:
                            i7 = iArr1[i6 + 1][i4];
                            break;
                        case 124:
                            i5 >>= (int)(l1 - ((155 - (by1 * iFld)) << (--l1)));
                            i5 += (--i5);
                            iArr2[i4] = (int)((long)((i7 - i4) - fFld) & (i7 += (int)(153L % ((i7++) | 1))));
                            break;
                        case 129:
                            s1 = (short)(-((++i5) + (13 + (i4 * i7))));
                            l1 = (lArr[iFld + 1]--);
                            b1 = (((long)(d1 * iFld) << (long)(0.221F - (--fArr[iFld]))) > ((i4 + iFld) - (--lArr[iFld
                                - 1])));
                            i5 = (int)((by1 + (i7 -= (int)l1)) + ((i8 - i6) ^ i7));
                            break;
                        default:
                            l1 = iArr1[i6 - 1][i4 - 1];
                        }
                        i7 -= (int)(((i5 % (iFld | 1)) - (~(++l1))) - (i5--));
                        l1 >>>= ((-by1) + l1);
                        iArr2[iFld - 1] = (int)((-(d1 * i7)) - ((l1 + d2) + (i7--)));
                        i7 = (int)(((++by1) + (0.11809 * l1)) - i8);
                    }
                }
                break;
            }
        } while (++i4 < 83);
    case 15:
        iArr2[(i8 >>> 1) % N] *= ((--i7) + ((by1 - i8) + (-857 * i5)));
        break;
    }

    System.out.println("d1 i4 i5 = " + Double.doubleToLongBits(d1) + "," + i4 + "," + i5);
    System.out.println("by1 i6 i7 = " + by1 + "," + i6 + "," + i7);
    System.out.println("s1 l1 b1 = " + s1 + "," + l1 + "," + (b1 ? 1 : 0));
    System.out.println("i8 d2 iArr1 = " + i8 + "," + Double.doubleToLongBits(d2) + "," + checkSum(iArr1));
    System.out.println("lArr iArr2 fArr = " + checkSum(lArr) + "," + checkSum(iArr2) + "," +
        Double.doubleToLongBits(checkSum(fArr)));

    System.out.println("iFld fFld = " + iFld + "," + Float.floatToIntBits(fFld));

    System.out.println("dMeth_check_sum: " + dMeth_check_sum);
}
}
