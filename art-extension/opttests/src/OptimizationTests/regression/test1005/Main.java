/*
 * Copyright (C) 2015 Intel Corporation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Generated by Dalvik Fuzzer tool (3.4.001). Tue Dec  9 00:28:20 2014
package OptimizationTests.regression.test1005;

import OptimizationTests.regression.shared.*;

public class Main extends FuzzerUtils {

    public static final int N = 100;

    public static int t0=9573, b9=20265;

    public static long ut_check_sum = 0;

public static void ut(long udb) {

    double a=-46.848;
    long cc[]=new long[N];
    short b=15758;
    float w4r=-36.825F;
    boolean hew=false;
    byte w=-89;
    int e9=50151, r1w[]=new int[N];

    init(cc, 4023290298585713844L);
    init(r1w, 55759);

    for (e9 = 2; e9 < 96; e9++) {
        switch (((((int)(e9 * w4r)) >>> 1) % 1) + 20) {
        case 20:
            cc[e9] /= (b | 1);
            b = w;
            udb /= (long)((long)((w4r--) * (t0 = e9)) | 1);
            udb = t0;
            break;
        default:
            udb += e9;
        }
        t0 >>= (t0 >>= t0);
        if ((hew || true) || (((udb * 37140) - (udb + udb)) == ((-6126234615125605914L << (-29412 >> (e9 % (e9 | 1))))
            * (a + t0)))) break;
        w4r -= (~(r1w[e9 + 1] = (int)(-(w4r + -31472))));
    }
    t0 -= (-t0);
    a = e9;
    ut_check_sum += udb + e9 + Float.floatToIntBits(w4r) + b + w + (hew ? 1 : 0) + Double.doubleToLongBits(a) +
        checkSum(cc) + checkSum(r1w);
}

public static void main(String[] obr) {

    double l=-108.187;
    short z=4085;
    long lc=-4495038316706870787L, g=-4881687622353645931L, hs=-5793015748721466029L, y4a[]=new long[N];
    float c=4.970F;
    byte xru=127, kk[]=new byte[N];
    int t=-25436, u=-708, k=-56578, fr=-6148, s[]=new int[N];

    init(y4a, -4682282049024385820L);
    init(kk, (byte)113);
    init(s, -7641);

    t = 1;
    do {
        lc *= (long)(((-26531 * (l++)) + (-20.725F + t)) - t);
        lc = (((15788469094174053L & (t0++)) * lc) * y4a[t - 1]);
        c *= (t0--);
        z |= (short)((--t0) + (kk[t]--));
        for (u = 1; u < 13; ++u) {
            t0 = (int)((t0++) >> (long)((g * hs) + (l + t0)));
            k = 1;
            do {
                hs |= (-z);
                t0 += k;
                t0 += (k ^ g);
                t0 *= (int)((-37673 - (t + -7717155537073563767L)) - c);
                t0 = (int)((g++) + (-l));
            } while (++k < 3);
        }
        ut(u * (t0++));
        l *= (l -= (t0--));
        for (b9 = 1; b9 < 49; b9++) {
            if ((((b9 >> b9) + (--lc)) >>> b9) >= (t0++)) break;
            t0 += (((b9 * u) + g) - lc);
            fr = 1;
            do {
                hs += (s[fr]++);
                xru <<= (byte)((hs += (long)c) - ((--t0) * (b9 - 3632164903961217391L)));
                t0 *= (int)(((g + t0) * (46617 + lc)) * (c * (z - hs)));
                t0 &= (int)-8140756264564659968L;
            } while (++fr < b9);
            t0 += (int)(-9482 - ((u | t0) - (c + u)));
            y4a[t + 1] *= (--g);
        }
    } while (++t < 77);

    System.out.println("t lc l = " + t + "," + lc + "," + Double.doubleToLongBits(l));
    System.out.println("c z u = " + Float.floatToIntBits(c) + "," + z + "," + u);
    System.out.println("g hs k = " + g + "," + hs + "," + k);
    System.out.println("fr xru y4a = " + fr + "," + xru + "," + checkSum(y4a));
    System.out.println("kk s = " + checkSum(kk) + "," + checkSum(s));

    System.out.println("t0 b9 = " + t0 + "," + b9);

    System.out.println("ut_check_sum: " + ut_check_sum);
}
}
