/*
 * Copyright (C) 2015 Intel Corporation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Generated by Dalvik Fuzzer tool (3.5.001). Mon May 11 21:34:20 2015
package OptimizationTests.regression.test2039;

import OptimizationTests.regression.shared.*;

public class Main extends FuzzerUtils {

    public static final int N = 100;

    public static int iFld=26435;
    public static double dFld=-47.69059;

    public static long lMeth_check_sum = 0;

public static long lMeth(long l1, int i3, int i4) {

    float f2=0.806F;
    int i5=10, i6=-12, iArr1[][]=new int[N][N];
    byte by1=-114, by2=88;
    long lArr[]=new long[N];

    init(lArr, -1406L);
    init(iArr1, -34911);

    i5 = 1;
    do {
        i3 <<= (int)((iFld *= -12) + ((dFld--) + (iFld - l1)));
        f2 += (--i3);
        by1 <<= (byte)(((14 - lArr[i5]) * (-159 - l1)) - iFld);
        i4 += i5;
        i4 ^= (int)((i5 + (--f2)) * (l1 -= (iFld++)));
        i3 += (-8 + (i5 * i5));
        for (i6 = 24; i6 > i5; i6 -= 3) {
            l1 *= 240;
            f2 += (iArr1[i5][i6]--);
            l1 = (long)((l1 * (-2.126383 + (iFld - iFld))) - ((iFld + by2) - f2));
            f2 += (i3 >> (i4--));
        }
    } while (++i5 < 79);
    long meth_res = l1 + i3 + i4 + i5 + Float.floatToIntBits(f2) + by1 + i6 + by2 + checkSum(lArr) + checkSum(iArr1);
    lMeth_check_sum += meth_res;
    return (long)meth_res;
}

public static void main(String[] strArr) {

    float f=-87.469F, f1=-20.335F;
    int i=-8, i1=230, i2=2, i7=13, i8=0, iArr[]=new int[N];
    byte by=21;
    double d=49.69127, dArr[]=new double[N];
    boolean b=true, bArr[]=new boolean[N];
    long l=-46918L;
    short s=-10029;

    init(iArr, -59);
    init(dArr, 117.45241);
    init(bArr, true);

    i = 1;
    while (++i < 76) {
        iFld = (20425 * iArr[i + 1]);
        iFld |= (int)(((s += (short)iFld) / ((long)dArr[i - 1] | 1)) * (iFld--));
        f = ((Math.abs(f) - -108) * (l - (-(-(by - l)))));
        bArr[i] = bArr[i];
        iFld += (int)(d - ((iFld * 1390474098L) - i));
        iFld *= (int)((i - (l | iFld)) * iFld);
        iFld <<= 112;
    }
    for (i1 = 98; i1 > 5; i1 -= 2) {
        iFld += i1;
        iArr[i1 - 1] >>= (int)(((d - iFld) - (l * f)) + ((s = (short)-11) - (iFld++)));
        i2 = 1;
        while (++i2 < i1) {
            s -= (short)(l + (l++));
            iFld += (++iFld);
            iFld *= i;
            iArr[i2] >>= (int)(i2 + ((-(i2 - d)) + l));
            iFld += (9 + (i2 * i2));
        }
        l = (long)f1;
        iFld = (int)(lMeth(by - l, iFld, iFld--) * i2);
        iFld >>= ((++iFld) + i);
        iFld <<= (int)((iFld++) + 3043901787L);
    }
    for (i7 = 89; i7 > 4; --i7) {
        iFld = (int)((f + (++l)) % ((long)(Math.abs(l) - Math.sqrt(dFld)) | 1));
        b = (!(b = (-12553 >= (iFld -= i7))));
        l += (iFld = ((i8 + i2) - (i8 * by)));
    }

    System.out.println("i s f = " + i + "," + s + "," + Float.floatToIntBits(f));
    System.out.println("l by d = " + l + "," + by + "," + Double.doubleToLongBits(d));
    System.out.println("i1 i2 f1 = " + i1 + "," + i2 + "," + Float.floatToIntBits(f1));
    System.out.println("i7 b i8 = " + i7 + "," + (b ? 1 : 0) + "," + i8);
    System.out.println("iArr dArr bArr = " + checkSum(iArr) + "," + Double.doubleToLongBits(checkSum(dArr)) + "," +
        checkSum(bArr));

    System.out.println("iFld dFld = " + iFld + "," + Double.doubleToLongBits(dFld));

    System.out.println("lMeth_check_sum: " + lMeth_check_sum);
}
}
