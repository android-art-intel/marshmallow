/*
 * Copyright (C) 2015 Intel Corporation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Generated by Dalvik Fuzzer tool (3.4.001). Thu Dec 25 18:09:47 2014
package OptimizationTests.regression.test1089;

import OptimizationTests.regression.shared.*;

public class Main extends FuzzerUtils {

    public static final int N = 100;

    public static int hl=-26410;
    public static long o=5722098600573030000L;
    public static byte a=44;
    public static short ype=-4756;

    public static long bh_check_sum = 0;

public static long bh() {

    float lm=-47.470F;
    int g=33564, x9=60540, li4=19413, h[]=new int[N];
    long k[][]=new long[N][N];
    short mxm[]=new short[N];

    init(h, 25841);
    init(mxm, (short)32634);
    init(k, 3882821428451601260L);

    g = 76;
    do {
        for (x9 = 1; x9 < 40; ++x9) {
            o *= g;
            li4 = 87;
            while (--li4 > 0) {
                if (((-(--hl)) != ((++h[g + 1]) - (-o))) | (((--lm) * (hl - g)) < 15.805)) break;
                hl *= (int)(((--o) + (li4 - ype)) + (h[x9 + 1] - hl));
                h[x9 + 1] |= (int)((o + lm) * (ype--));
                hl = (int)(((mxm[g - 1] <<= (short)-12181) - o) - ((a * li4) - ype));
            }
            hl <<= (int)(-(k[x9 + 1][g]--));
            hl += x9;
        }
    } while (--g > 0);
    long meth_res = g + x9 + li4 + Float.floatToIntBits(lm) + checkSum(h) + checkSum(mxm) + checkSum(k);
    bh_check_sum += meth_res;
    return (long)meth_res;
}

public static void main(String[] e) {

    float m4x=-89.936F;
    int p=42321, b=19839, q=-9442, m=-21658, f5=-42793, o9=42612, l4[]=new int[N];
    long u35=8624928644221707694L, i[]=new long[N];
    double d=78.748;
    short j[]=new short[N];
    boolean z=false;

    init(l4, 6325);
    init(i, -7507287222940104743L);
    init(j, (short)5907);

    for (p = 3; p < 79; ++p) {
        m4x -= (l4[p - 1]++);
        b -= (int)d;
    }
    for (q = 4; q < 94; ++q) {
        b -= (int)(((--u35) >> q) * (l4[q - 1]++));
        u35 -= (long)(((--d) + p) - ((q + b) + (m4x - b)));
        for (m = 3; m < 62; ++m) {
            l4[q] -= (int)(((q - u35) - (b * -6687868676441237051L)) + ((p + m4x) - (p - q)));
            l4[q - 1] -= (int)i[q - 1];
            m4x = (~q);
            m4x += (b++);
            b = (int)((m + (p + d)) + (-26257 + (-9013910395661127877L * (a % ((long)d | 1)))));
            u35 = ((p + p) * (i[q + 1] += (u35 % (u35 | 1))));
            z = ((z = (m4x == m4x)) | false);
        }
        j[q + 1] = (short)f5;
        f5 += (q | u35);
        for (long tu3 : i) {
            m4x -= (f5++);
        }
        d = (m4x--);
    }
    for (int pjv : l4) {
        o9 = (f5++);
        b = (int)(u35 - d);
        o9 &= q;
        f5 *= (int)bh();
        hl = (int)(((q - 40.264F) * (b + b)) + (f5--));
    }

    System.out.println("p m4x b = " + p + "," + Float.floatToIntBits(m4x) + "," + b);
    System.out.println("d q u35 = " + Double.doubleToLongBits(d) + "," + q + "," + u35);
    System.out.println("m z f5 = " + m + "," + (z ? 1 : 0) + "," + f5);
    System.out.println("o9 l4 i = " + o9 + "," + checkSum(l4) + "," + checkSum(i));
    System.out.println("j = " + checkSum(j));

    System.out.println("a o hl = " + a + "," + o + "," + hl);
    System.out.println("ype = " + ype);

    System.out.println("bh_check_sum: " + bh_check_sum);
}
}
