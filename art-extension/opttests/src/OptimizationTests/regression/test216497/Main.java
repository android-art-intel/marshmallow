/*
 * Copyright (C) 2015 Intel Corporation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Generated by Dalvik Fuzzer tool (3.3.003). Mon Aug 11 19:36:36 2014
package OptimizationTests.regression.test216497;

import OptimizationTests.regression.shared.*;

public class Main extends FuzzerUtils {

public static final int N = 150;

    public static boolean mo0=true;
    public static short afs=12979;

public static void main(String[] vca) {

    boolean cz=true;
    double ho=65.995;
    short jp[]=new short[N];
    float ps=53.852F, uxm=-80.534F;
    int ev=-45821, rta=-28269, ys0=-28692, ntd=-26129, bu=48520, ip=-36567, dj=-8241, ijl=-23989, m[]=new int[N];
    byte cr6=-29;
    long fi=6329081663224637925L, d=3227413127563697745L, k[]=new long[N];

    init(m, -14395);
    init(k, -429989300567966304L);
    init(jp, (short)-5043);

    for (ev = 8; ev < 136; ++ev) {
        m[ev] = (int)k[ev];
        for (rta = 2; rta < 97; rta++) {
            ys0 = 1;
            do {
                afs += (short)(ys0 * ev);
                fi += (((ys0 * ps) + rta) - ys0);
                fi += ys0;
                ntd += (ys0 + ev);
                fi ^= ys0;
                fi += (ys0 * ys0);
            } while (++ys0 < 3);
            ntd = ys0;
            k[ev + 1] = (((ntd--) + (rta + -38833)) + ((fi--) - (-fi)));
        }
        ntd += (int)((jp[ev - 1] |= (short)(-6241516312774314879L | (long)(39.868 - (ntd + -17727)))) - ((-m[ev]) + (fi
            - fi)));
        for (bu = 4; bu < 113; ++bu) {
            k[bu + 1] |= cr6;
            ip = 118;
            while (--ip > 0) {
                ntd += (((ip * d) + ys0) - uxm);
                ntd = (int)((ntd++) * ((ntd <<= (int)-801084931310176116L) * (++d)));
                uxm *= (float)(ho--);
                dj += (((ip * d) + fi) - bu);
                dj ^= (int)((ntd <<= (int)(52327 / ((long)(rta * ps) | 1))) + (ps--));
                dj = ntd;
                fi += ((long)ip | (long)d);
                mo0 = ((--ntd) != (ntd++));
                dj += (((ip * bu) + dj) - d);
                cr6 *= (byte)(m[bu + 1]--);
            }
            dj += (bu + ip);
            ijl = 1;
            do {
                ntd += (ijl * ijl);
                dj += ijl;
            } while (++ijl < 35);
        }
    }

    System.out.println("ev rta ys0 = " + ev + "," + rta + "," + ys0);
    System.out.println("ntd fi ps = " + ntd + "," + fi + "," + Float.floatToIntBits(ps));
    System.out.println("cr6 uxm bu = " + cr6 + "," + Float.floatToIntBits(uxm) + "," + bu);
    System.out.println("ip d ho = " + ip + "," + d + "," + Double.doubleToLongBits(ho));
    System.out.println("dj ijl cz = " + dj + "," + ijl + "," + cz);
    System.out.println("m k jp = " + checkSum(m) + "," + checkSum(k) + "," + checkSum(jp));
    
    System.out.println("afs mo0 = " + afs + "," + mo0);
}
}
