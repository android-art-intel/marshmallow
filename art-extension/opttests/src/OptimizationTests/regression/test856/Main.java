/*
 * Copyright (C) 2015 Intel Corporation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Generated by Dalvik Fuzzer tool (3.4.001). Sun Nov 16 02:44:58 2014
package OptimizationTests.regression.test856;

import OptimizationTests.regression.shared.*;

public class Main extends FuzzerUtils {

    public static final int N = 100;

    public static int oec=-2592;

public static void main(String[] b) {

    byte lw5=120;
    long w6x=853523865288507708L, nd[]=new long[N];
    boolean r=false;
    float rm=-24.851F, m=-11.76F, vz[][]=new float[N][N];
    int g=-41474, u=-47469, xp=7253, sir=43287, ihi=62295, t=28841, n[]=new int[N];
    double wd0=13.139;
    short n7i=3506, c[]=new short[N];

    init(n, 55856);
    init(vz, 19.385F);
    init(c, (short)-23599);
    init(nd, -3842838550624043435L);

    for (g = 4; g < 94; g++) {
        n[g + 1] -= n[g + 1];
        n[g - 1] = (int)((-g) * ((n[g - 1] *= -63443) * (rm - g)));
        if ((-60 < ihi) && r) {
            w6x >>= (((u + w6x) - (-3590332157251403765L + (u++))) - ((g - g) * (-55067 - (w6x + u))));
            u = n[g];
            xp = 1;
            while (++xp < 77) {
                sir -= sir;
                oec = 1;
                while (++oec < 66) {
                    w6x <<= (u = (int)(n7i *= (short)(vz[g][xp + 1] += (float)wd0)));
                    sir = (int)w6x;
                    sir -= (-7178 + (7547 - ihi));
                    t = (int)(wd0 + ((t + w6x) - (w6x + 3496855932716042782L)));
                    ihi = (int)(rm + c[oec]);
                }
                t *= u;
                n[xp] -= (int)(rm + (-(g - m)));
            }
            w6x -= (--lw5);
        } else {
            ihi = (int)3211273945869891828L;
            sir += (int)(((sir - u) + -35.460F) * w6x);
            w6x += g;
        }
        nd[(sir >>> 1) % N] = (((xp >> u) - (12428 / ((-(-28387 - lw5)) | 1))) - ((g - g) - (xp * sir)));
        switch ((g % 2) + 115) {
        case 115:
            rm += (++ihi);
            break;
        case 116:
            m += ((long)g | (long)t);
            break;
        default:
            u *= sir;
        }
    }

    System.out.println("g rm w6x = " + g + "," + Float.floatToIntBits(rm) + "," + w6x);
    System.out.println("u xp sir = " + u + "," + xp + "," + sir);
    System.out.println("n7i wd0 ihi = " + n7i + "," + Double.doubleToLongBits(wd0) + "," + ihi);
    System.out.println("t m lw5 = " + t + "," + Float.floatToIntBits(m) + "," + lw5);
    System.out.println("r n vz = " + (r ? 1 : 0) + "," + checkSum(n) + "," + Double.doubleToLongBits(checkSum(vz)));
    System.out.println("c nd = " + checkSum(c) + "," + checkSum(nd));

    System.out.println("oec = " + oec);
}
}
