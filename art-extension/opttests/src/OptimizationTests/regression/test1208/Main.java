/*
 * Copyright (C) 2015 Intel Corporation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Generated by Dalvik Fuzzer tool (3.5.001). Sun Apr 19 16:08:31 2015
package OptimizationTests.regression.test1208;

import OptimizationTests.regression.shared.*;

public class Main extends FuzzerUtils {

    public static final int N = 100;

    public static int iFld=-103;

public static void main(String[] strArr) {

    float f=1.548F, f1=-39.268F;
    byte byArr[]=new byte[N];
    boolean b=false;
    double d=34.98205;
    long l=22929L, l1=4290312691L;
    short s=-10626;
    int i=-44077, i1=17533, i2=9, i3=-60, i4=-240, i5=0, iArr[]=new int[N], iArr1[]=new int[N];

    init(byArr, (byte)67);
    init(iArr, 0);
    init(iArr1, -16044);

    for (i = 3; i < 92; i++) {
        i1 ^= (int)l;
        i1 = i1;
    }
    for (byte by : byArr) {
        iArr[(i1 >>> 1) % N] |= (iFld++);
        for (i2 = 1; i2 < 98; ++i2) {
            iArr[i2 - 1] <<= (int)106L;
            f -= (iArr[i2] = (int)-1957550375042426249L);
            iFld = (int)((i1--) + l);
            f = (-f);
            for (i3 = 1; i3 < i2; i3++) {
                i1 -= (--iArr[i2]);
            }
            l = (long)((8 - (2 - (f * 3))) * (iFld &= (iArr[i2] += i3)));
        }
        s -= (short)Math.min(i, iFld);
        for (i4 = 4; i4 < 81; i4++) {
            if (b) continue;
            iFld <<= (int)(i2 + l);
            l += (-12 + (i4 * i4));
            d = ((i & (i1++)) - (--i1));
            l = ((++iArr1[i4 + 1]) * ((5 - (-(i - i1))) * (++iFld)));
            b = true;
            s = (short)(~(long)(i1 *= (int)(d * 0)));
            l *= (long)(((l - d) / ((iFld * l) | 1)) + iArr1[i4]);
            i5 += ((i1 >>>= i) * ((0 - i3) * (i2 << i5)));
            l1 = (long)(d * ((f1 + 49201L) + (i2 << i)));
        }
    }

    System.out.println("i i1 l = " + i + "," + i1 + "," + l);
    System.out.println("i2 f i3 = " + i2 + "," + Float.floatToIntBits(f) + "," + i3);
    System.out.println("s i4 b = " + s + "," + i4 + "," + (b ? 1 : 0));
    System.out.println("d i5 l1 = " + Double.doubleToLongBits(d) + "," + i5 + "," + l1);
    System.out.println("f1 byArr iArr = " + Float.floatToIntBits(f1) + "," + checkSum(byArr) + "," + checkSum(iArr));
    System.out.println("iArr1 = " + checkSum(iArr1));

    System.out.println("iFld = " + iFld);
}
}
