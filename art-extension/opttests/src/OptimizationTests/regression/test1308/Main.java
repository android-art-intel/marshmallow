/*
 * Copyright (C) 2015 Intel Corporation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Generated by Dalvik Fuzzer tool (3.5.001). Wed Jan 28 04:50:47 2015
package OptimizationTests.regression.test1308;

import OptimizationTests.regression.shared.*;

public class Main extends FuzzerUtils {

    public static final int N = 100;

    public static float fFld=-1.2F;
    public static long lFld=-6L;

    public static long iMeth_check_sum = 0;

public static int iMeth(int i2, int i3, short s1) {

    float f=-2.943F;
    int i4=49546, i5=-14, i6=-6470, iArr[]=new int[N];
    long l=-2L;

    init(iArr, 47158);

    for (i4 = 1; i4 < 76; ++i4) {
        for (i5 = 44; i5 > 1; i5 -= 2) {
            s1 += (short)(i5 - i3);
            iArr[i5] += i5;
        }
        i3 -= (int)Double.doubleToRawLongBits((--i3) - (i3 + i2));
        l = (--i3);
        if (3943360803L > l) continue;
        i3 += (((i4 * i6) + f) - i5);
        i6 = ((i3--) << i4);
        l = (-Math.min(i5, (int)(i3 * f)));
    }
    i3 *= (int)(f++);
    i2 |= (int)((--i6) + ((f * i6) + Math.max(4, -40)));
    long meth_res = i2 + i3 + s1 + i4 + i5 + l + i6 + Float.floatToIntBits(f) + checkSum(iArr);
    iMeth_check_sum += meth_res;
    return (int)meth_res;
}

public static void main(String[] strArr) {

    float f1=-2.544F, fArr[]=new float[N];
    double d=1.35971;
    int i=6, i1=148, i7=-32421, i8=232, i9=-14, i10=0, iArr1[][]=new int[N][N];
    boolean b=false, bArr[]=new boolean[N];
    byte by=101;
    short s=15373;

    init(iArr1, -9);
    init(fArr, 107.206F);
    init(bArr, true);

    i = 1;
    while (++i < 88) {
        i1 >>= (s--);
        by >>>= (byte)iMeth(i, Float.floatToRawIntBits((float)(d * i)), (short)(-18197));
        for (i7 = i; i7 < 26; i7++) {
            i1 <<= (s -= (short)((iArr1[i - 1][i7 + 1]--) + -60760));
            i8 = 1;
            while ((i8 += 3) < 73) {
                i1 -= (int)lFld;
                d += ((i1 = (i9 * -32211)) - (--lFld));
                i10 = Float.floatToRawIntBits(fArr[i7]);
                i9 = i10;
                bArr[i - 1] = ((iArr1[i8 + 1][i8 - 1] - (12 + i)) <= (i10 - (-2.993F * (-fFld))));
            }
            fFld *= (-12 + by);
            i1 += (((i7 * i8) + i8) - i10);
            bArr[(i >>> 1) % N] = b;
            lFld = (iArr1[i7 + 1][i7] - lFld);
            if (b && ((iArr1[i7 + 1][i7 - 1]++) != 56.477F)) continue;
            d = (++lFld);
            i1 = (int)(((++lFld) + 1024084288L) + lFld);
            i9 += (int)((i1++) * (-(--d)));
        }
    }
    f1 = 1;
    while (++f1 < 77) {
        i9 *= (int)(fArr[(int)(f1 - 1)]--);
        iArr1[(int)(f1)][(int)(f1 - 1)] = i1;
        i10 = (int)f1;
        b = (bArr[(int)(f1 - 1)] = ((i9++) <= (i7 + lFld)));
        i1 &= (--s);
    }

    System.out.println("i i1 s = " + i + "," + i1 + "," + s);
    System.out.println("by d i7 = " + by + "," + Double.doubleToLongBits(d) + "," + i7);
    System.out.println("i8 i9 i10 = " + i8 + "," + i9 + "," + i10);
    System.out.println("b f1 iArr1 = " + (b ? 1 : 0) + "," + Float.floatToIntBits(f1) + "," + checkSum(iArr1));
    System.out.println("fArr bArr = " + Double.doubleToLongBits(checkSum(fArr)) + "," + checkSum(bArr));

    System.out.println("lFld fFld = " + lFld + "," + Float.floatToIntBits(fFld));

    System.out.println("iMeth_check_sum: " + iMeth_check_sum);
}
}
