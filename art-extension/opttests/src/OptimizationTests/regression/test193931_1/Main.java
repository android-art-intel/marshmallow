/*
 * Copyright (C) 2015 Intel Corporation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Generated by Dalvik Fuzzer tool (3.3.001). Sat May 10 17:07:05 2014
package OptimizationTests.regression.test193931_1;

import OptimizationTests.regression.shared.*;

public class Main extends FuzzerUtils {

public static final int N = 300;

    public static float hxi=126.716F;
    public static byte jc=112;

public static void main(String[] e) {

    short bh=-11010;
    double ww5[]=new double[N];
    float ke=-122.1012F, nk=103.534F, e7m[]=new float[N];
    long s8=-1256214351445305524L, yla=1751980791837240206L, d=-8017202699421476163L, oj=-6736092748250163585L,
        ag[]=new long[N];
    int xpd=-52353, x=37964, of=62142, c4=31222, ze=-20751, iq[]=new int[N];
    boolean fx=false;

    init(e7m, 88.814F);
    init(ww5, -85.384);
    init(iq, 1766);
    init(ag, -5977206853797752553L);

    xpd = 233;
    do {
        x = (int)e7m[xpd + 1];
        for (double g : ww5) {
            if (fx = (!((hxi * x) > iq[xpd - 1]))) continue;
            for (int z8g : iq) {
                x -= (xpd - (x--));
                iq[xpd] -= (int)(((x + of) - hxi) + (++x));
                s8 = (long)(ke--);
                of = ((iq[xpd]++) - ((-27586 - of) - (x++)));
                if ((s8 = (yla++)) != ((d++) + g)) {
                    of = (int)(++nk);
                    hxi += (((-(s8 = z8g)) * (x + of)) * (s8 * 62828));
                }
                iq[xpd - 1] /= (int)((long)(((x += of) * (x + hxi)) - of) | 1);
                of = of;
            }
            ag[xpd + 1] -= (xpd * (-of));
            d -= (long)(-39.992F * of);
            x = (int)((of * ke) + (++of));
            x *= (int)(d + xpd);
        }
    } while ( --xpd > 0 );
    switch ((((x + bh) >>> 1) % 1) + 54) {
    case 54:
        for (int qvv : iq) {
            for (c4 = 16; c4 < 294; c4 += 3) {
                iq[c4 + 1] = (int)(iq[c4] * ((of + xpd) - (oj--)));
            }
            if (!((fx = (x != ze)) && (fx = (false && fx)))) {
                x = (((c4 & qvv) - (jc + 61745)) >>> of);
            } else {
                yla -= (ag[(of >>> 1) % N]--);
            }
        }
        break;
    default:
        oj -= (-((c4 - x) + (x - yla)));
    }

    System.out.println("xpd x fx = " + xpd + "," + x + "," + fx);
    System.out.println("of s8 ke = " + of + "," + s8 + "," + Float.floatToIntBits(ke));
    System.out.println("nk yla d = " + Float.floatToIntBits(nk) + "," + yla + "," + d);
    System.out.println("bh c4 oj = " + bh + "," + c4 + "," + oj);
    System.out.println("ze e7m ww5 = " + ze + "," + Double.doubleToLongBits(checkSum(e7m)) + "," +
        Double.doubleToLongBits(checkSum(ww5)));
    System.out.println("iq ag = " + checkSum(iq) + "," + checkSum(ag));
    
    System.out.println("hxi jc = " + Float.floatToIntBits(hxi) + "," + jc);
}
}
