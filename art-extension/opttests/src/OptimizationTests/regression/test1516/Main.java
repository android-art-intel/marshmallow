/*
 * Copyright (C) 2015 Intel Corporation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Generated by Dalvik Fuzzer tool (3.5.001). Sat Feb 14 17:52:47 2015
package OptimizationTests.regression.test1516;

import OptimizationTests.regression.shared.*;

public class Main extends FuzzerUtils {

    public static final int N = 100;

    public static float fFld=-47.940F;

    public static long iMeth_check_sum = 0;
    public static long fMeth_check_sum = 0;

public static int iMeth(int i3, long l1, int i4) {

    int i5=-210, i6=237, i7=-14, iArr[]=new int[N];
    float fArr[]=new float[N];
    long lArr1[]=new long[N];
    byte byArr[]=new byte[N];
    double d1=-62.28993;

    init(fArr, -95.441F);
    init(iArr, -54748);
    init(byArr, (byte)3);
    init(lArr1, -9257L);

    for (i5 = 4; i5 < 87; ++i5) {
        i3 = (-i5);
        fFld -= ((i3 += (int)(l1 - i3)) - ((l1 = i5) - fArr[i5]));
        for (i6 = 1; i6 < 67; ++i6) {
            iArr[i5] = (int)(((++l1) >> (-byArr[i6 - 1])) - 185);
        }
        lArr1[i5] -= i4;
        l1 -= ((++i3) >> (long)((i3 + fFld) + (i6 + d1)));
        fFld += -228L;
        l1 += (((i5 * i3) + i3) - i4);
    }
    for (i7 = 3; i7 < 97; i7++) {
        iArr[i7] -= i4;
        l1 = (long)(++d1);
    }
    long meth_res = i3 + l1 + i4 + i5 + i6 + Double.doubleToLongBits(d1) + i7 + Double.doubleToLongBits(checkSum(fArr))
        + checkSum(iArr) + checkSum(byArr) + checkSum(lArr1);
    iMeth_check_sum += meth_res;
    return (int)meth_res;
}

public static float fMeth() {

    short s1=-8316;
    int i8=22839, i9=5, i10=11, i11=-2, iArr2[]=new int[N];
    float fArr1[]=new float[N];
    long l2=12L;
    double dArr[]=new double[N];

    init(fArr1, 120.322F);
    init(iArr2, -32827);
    init(dArr, 70.50451);

    for (i8 = 1; i8 < 95; i8++) {
        i9 += i8;
        for (i10 = 1; i10 < 27; ++i10) {
            for (i11 = 1; i11 < i8; ++i11) {
                switch (((3 >>> 1) % 3) + 1) {
                case 1:
                    fArr1[i8 + 1] -= Math.min(i10, iArr2[(i9 >>> 1) % N]);
                    break;
                case 2:
                    s1 += (short)(++fFld);
                    l2 = (long)(-58 + (++fFld));
                    i9 = i11;
                    i9 += (int)(++dArr[i10 + 1]);
                case 3:
                    iArr2[i10] -= i11;
                    iArr2[i11] *= (int)((iArr2[i10 + 1] -= (int)(++l2)) + Long.reverseBytes(i11 + i11));
                    break;
                }
            }
        }
    }
    long meth_res = i8 + i9 + i10 + i11 + s1 + l2 + Double.doubleToLongBits(checkSum(fArr1)) + checkSum(iArr2) +
        Double.doubleToLongBits(checkSum(dArr));
    fMeth_check_sum += meth_res;
    return (float)meth_res;
}

public static void main(String[] strArr) {

    short s=-13402, sArr[]=new short[N];
    int i=-27004, i1=-27363, i2=13875, i12=7, i13=-34, iArr1[][]=new int[N][N];
    boolean b=false;
    float f=1.947F;
    long l=-4937658652792970804L, lArr[]=new long[N];
    double d=0.103281, d2=-94.44692;

    init(lArr, 1483325795673946589L);
    init(iArr1, -9);
    init(sArr, (short)-11360);

    for (i = 5; i < 83; ++i) {
        f += (i * i);
        d -= i1;
        l >>= (i1 * -45517);
    }
    for (i2 = 4; i2 < 77; ++i2) {
        i1 = (i1++);
        lArr[i2 + 1] = (long)(((i2 * i1) * d) - iMeth(-(iArr1[i2 - 1][i2]++), i1 - i2, (int)(-6L - i)));
        if (i >= ((lArr[i2 - 1]--) + (-(i * i)))) {
            s = (short)(i1 = i);
            fFld += (i2 * i2);
            s /= (short)((-(l++)) | 1);
            f += (float)(d2 - ((--iArr1[i2 + 1][i2]) * (-2294340643L + fMeth())));
        } else {
            for (i12 = 1; i12 < 33; i12 += 3) {
                l += i12;
                iArr1[i12 - 1][i12] *= (int)(lArr[i12 - 1]++);
                iArr1[i12][i12] -= (--i1);
            }
            i1 = (int)((i12 + (i1--)) - (-3612 - f));
            for (i13 = 1; i13 < 70; i13++) {
                iArr1[i13 - 1][i13 + 1] -= (int)(((i13 * i1) + (i12 >> l)) + l);
                sArr[i2] &= (short)i1;
            }
        }
        i1 /= (int)((--l) | 1);
        fFld -= (i1++);
        b = b;
        i1 = ((i1++) + ((i13 + -4) * (i2 * i)));
        i1 = (sArr[i2]++);
    }

    System.out.println("i f d = " + i + "," + Float.floatToIntBits(f) + "," + Double.doubleToLongBits(d));
    System.out.println("i1 l i2 = " + i1 + "," + l + "," + i2);
    System.out.println("s d2 i12 = " + s + "," + Double.doubleToLongBits(d2) + "," + i12);
    System.out.println("i13 b lArr = " + i13 + "," + (b ? 1 : 0) + "," + checkSum(lArr));
    System.out.println("iArr1 sArr = " + checkSum(iArr1) + "," + checkSum(sArr));

    System.out.println("fFld = " + Float.floatToIntBits(fFld));

    System.out.println("iMeth_check_sum: " + iMeth_check_sum);
    System.out.println("fMeth_check_sum: " + fMeth_check_sum);
}
}
