/*
 * Copyright (C) 2015 Intel Corporation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Generated by Dalvik Fuzzer tool (3.5.001). Sun Mar  1 02:02:47 2015
package OptimizationTests.regression.test1625;

import OptimizationTests.regression.shared.*;

public class Main extends FuzzerUtils {

    public static final int N = 100;

    public static int iFld=18741;
    public static short sFld=31862, sArrFld[]=new short[N];

    static {
        init(sArrFld, (short)-11179);
    }

    public static long lMeth_check_sum = 0;

public static long lMeth(float f1, float f2) {

    int i3=-10, i4=-1, i5=3, i6=92, iArr[]=new int[N];
    long l1=-59L, lArr[]=new long[N];
    float fArr[][]=new float[N][N];

    init(iArr, 235);
    init(lArr, -76L);
    init(fArr, 0.707F);

    for (i3 = 1; i3 < 90; i3++) {
        i4 += (int)(((i4 + l1) * (i4++)) - i3);
        for (i5 = 4; i5 < 75; i5++) {
            i4 = (i4 <<= i5);
            i4 -= (int)(((i4 + i4) + (iArr[i3] += (int)f1)) + (-(i5 << i4)));
            f1 = lArr[i3 + 1];
            i4 += (i4++);
            i6 = 1;
            do {
                i4 += ((long)i6 ^ (long)i4);
                i4 = (int)((l1++) + ((l1--) - (i5 * i6)));
                l1 += i6;
                f2 -= ((iArr[i3]--) + (--fArr[i5][i3 - 1]));
            } while (++i6 < 67);
        }
    }
    long meth_res = Float.floatToIntBits(f1) + Float.floatToIntBits(f2) + i3 + i4 + l1 + i5 + i6 + checkSum(iArr) +
        checkSum(lArr) + Double.doubleToLongBits(checkSum(fArr));
    lMeth_check_sum += meth_res;
    return (long)meth_res;
}

public static void main(String[] strArr) {

    boolean b=false;
    int i=54812, i1=-169, i2=-43, i7=-245, i8=12, i9=12866, i10=38861, iArr1[]=new int[N];
    byte by=-109, byArr[]=new byte[N];
    long l=-120523691692647607L, lArr1[]=new long[N];
    double d=0.110704;
    float f=107.141F;

    init(lArr1, -4L);
    init(iArr1, -1);
    init(byArr, (byte)-84);

    for (i = 2; i < 97; ++i) {
        i1 *= (int)((l + (i1 - l)) * i1);
    }
    i2 = 1;
    while (++i2 < 79) {
        i1 = Math.min(i2, (int)(-(f + i1)));
        f -= (float)((++d) + lMeth(f++, i2 - i1));
        l *= (~sFld);
        l += ((long)i2 ^ (long)i1);
        lArr1[i2 + 1] -= ((i1 >>= i1) + (i1 &= iArr1[i2]));
        i7 += (int)(0 * l);
        i8 >>= iArr1[i2 - 1];
        i1 -= ((++by) * (sArrFld[i2 + 1]--));
        b = (b && (b = (b = true)));
    }
    for (byte by1 : byArr) {
        lArr1[(53387 >>> 1) % N] = ((-by) - (-50479 - (i8 >>>= i2)));
        i1 = (int)(i9 * -69L);
    }
    for (iFld = 3; iFld < 95; iFld++) {
        i9 = (int)(((++l) + i2) * (i7 = (int)(f / 12)));
        d -= (by--);
        i9 += (i1 - (i8 << (i1 * i)));
        l = (((l * i2) + (i9++)) - l);
        for (i10 = 1; i10 < 46; i10++) {
            i7 <<= (i8--);
            i8 += (i10 * i10);
            f += (i9++);
            d *= Float.floatToRawIntBits(Float.floatToRawIntBits(f) - by);
        }
    }

    System.out.println("i i1 l = " + i + "," + i1 + "," + l);
    System.out.println("i2 f d = " + i2 + "," + Float.floatToIntBits(f) + "," + Double.doubleToLongBits(d));
    System.out.println("i7 i8 by = " + i7 + "," + i8 + "," + by);
    System.out.println("b i9 i10 = " + (b ? 1 : 0) + "," + i9 + "," + i10);
    System.out.println("lArr1 iArr1 byArr = " + checkSum(lArr1) + "," + checkSum(iArr1) + "," + checkSum(byArr));

    System.out.println("sFld iFld sArrFld = " + sFld + "," + iFld + "," + checkSum(sArrFld));

    System.out.println("lMeth_check_sum: " + lMeth_check_sum);
}
}
