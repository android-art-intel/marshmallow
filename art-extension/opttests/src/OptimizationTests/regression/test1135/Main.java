/*
 * Copyright (C) 2015 Intel Corporation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Generated by Dalvik Fuzzer tool (3.5.001). Sat Jan 10 01:12:17 2015
package OptimizationTests.regression.test1135;

import OptimizationTests.regression.shared.*;

public class Main extends FuzzerUtils {

    public static final int N = 100;

    public static int iFld=-13, iArrFld[]=new int[N];

    static {
        init(iArrFld, -6);
    }

    public static long iMeth_check_sum = 0;
    public static long lMeth_check_sum = 0;

public static int iMeth(long l2, int i8) {

    int i9=-246, i10=62768, i11=0, i12=-228, i13=11380;
    short s1=22223;
    long lArr[]=new long[N];
    float f1=73.388F;
    byte by1=30;

    init(lArr, -14L);

    for (i9 = 2; i9 < 95; i9++) {
        i10 = 1;
        while (++i10 < 83) {
            i8 += -7;
            i8 += (i8++);
        }
        l2 += i9;
        for (i11 = 1; i11 < i9; ++i11) {
            i8 += (int)(i8 -= (int)(l2--));
        }
        s1 >>= (short)i12;
        f1 = (++i8);
        for (i13 = 1; i13 < 64; i13++) {
            lArr[i9 + 1] += (long)((l2 - (i11 - 19)) - ((2.564F - (by1 - s1)) + (i9 - l2)));
            f1 = (-((i13 << i8) + iArrFld[i13]));
        }
    }
    long meth_res = l2 + i8 + i9 + i10 + i11 + s1 + i12 + Float.floatToIntBits(f1) + i13 + by1 + checkSum(lArr);
    iMeth_check_sum += meth_res;
    return (int)meth_res;
}

public static long lMeth(int i14) {

    int i15=-35957, i16=32129, i17=-18602, i18=-176;
    float f2=2.140F;
    long l3=-2L;

    for (i15 = 3; i15 < 77; ++i15) {
        i16 = 1;
        while (++i16 < 46) {
            l3 = (long)f2;
        }
        l3 <<= ((--i14) + ((++l3) * i15));
        i14 -= (int)(((i16 - -1901017188509886075L) * iFld) + (Double.longBitsToDouble(l3) - (l3 / (i16 | 1))));
        i14 += (int)((i14--) + f2);
        for (i17 = 4; i17 < 91; i17++) {
            i14 <<= (i16 + 0);
            for (i18 = 1; i18 < i15; i18++) {
                i14 <<= (--i14);
                i14 *= i15;
                i14 = i15;
            }
        }
    }
    long meth_res = i14 + i15 + i16 + l3 + Float.floatToIntBits(f2) + i17 + i18;
    lMeth_check_sum += meth_res;
    return (long)meth_res;
}

public static void main(String[] strArr) {

    int i=-32, i1=-33534, i2=-62, i3=-77, i4=5, i5=35978, i6=61153, i7=132, iArr[]=new int[N];
    short s=-18705;
    double d=36.11630;
    long l=3717139885L, l1=27L;
    float f=2.861F, fArr[][]=new float[N][N];
    byte by=-4;

    init(iArr, -128);
    init(fArr, 10.947F);

    if (((i6 <<= i2) - (--l1)) != (iArr[(i6 >>> 1) % N]++)) {
        i = 1;
        while (++i < 76) {
            i1 -= i1;
            f = i1;
            i1 = (int)((++by) * (++l));
            for (i2 = 1; i2 < 12; i2++) {
                f += (float)(d++);
            }
            f -= (((by + l) - (i1++)) - ((by - 0) - (iArr[i + 1]++)));
            iArr[i] >>>= (int)((l1 - (-18715 - i2)) - i);
            for (i3 = 2; i3 < 74; i3++) {
                i1 -= (int)(((iArr[i + 1]++) - (l1 * i2)) + (i1 - (s * d)));
            }
            i4 = 1;
            do {
                for (i5 = i4; i5 < 84; i5++) {
                    i1 = (i3 + Math.abs(iArr[i4 - 1]--));
                    i1 += (i5 ^ (long)f);
                    i1 += (int)(-((-151 + (i3 - i2)) >> (l * i)));
                    s *= (short)iArr[i5 + 1];
                    i1 += (int)((i1 ^= (i * i2)) + (Math.min(-86L, l1) - i3));
                }
                i1 = (--i6);
                i1 *= (int)fArr[i4][i4];
            } while (++i4 < i);
        }
        for (i7 = 4; i7 < 92; ++i7) {
            for (iFld = 1; iFld < 28; iFld++) {
                iArr[i7 + 1] <<= (int)((~(l1 * i7)) + ((-(iFld - i)) + (++s)));
                l >>>= (long)(((i6 + 0.109413) + (8 << iArr[iFld - 1])) * (++i6));
                i6 = (int)3882404420589647134L;
            }
        }
    } else {
        iMeth(((++i1) + lMeth(i1)) + ((i3 + i1) + (i7 * 29639)), i2);
    }

    System.out.println("i i1 f = " + i + "," + i1 + "," + Float.floatToIntBits(f));
    System.out.println("by l i2 = " + by + "," + l + "," + i2);
    System.out.println("d l1 i3 = " + Double.doubleToLongBits(d) + "," + l1 + "," + i3);
    System.out.println("s i4 i5 = " + s + "," + i4 + "," + i5);
    System.out.println("i6 i7 iArr = " + i6 + "," + i7 + "," + checkSum(iArr));
    System.out.println("fArr = " + Double.doubleToLongBits(checkSum(fArr)));

    System.out.println("iFld iArrFld = " + iFld + "," + checkSum(iArrFld));

    System.out.println("iMeth_check_sum: " + iMeth_check_sum);
    System.out.println("lMeth_check_sum: " + lMeth_check_sum);
}
}
